from Jade require "common/keccak/keccak1600/amd64/avx2/keccak1600.jinc"
from Jade require "common/keccak/keccak1600/amd64/avx2/keccakf1600.jinc"

param int SHAKE256_RATE = 136;

#[returnaddress="stack"]
fn __shake256_seed_A(reg ptr u8[BYTES_SEED_A] out, reg const ptr u8[BYTES_SEED_A] in, reg u64 ms) -> stack u8[BYTES_SEED_A], #msf reg u64
{
  stack u64[28] s_state;
  reg ptr u64[25] a_jagged_p;
  reg u256[7] state;
  reg u64 t l;
  reg u8 c;
  inline int INLEN OUTLEN k;
  reg u64 i;

  INLEN = BYTES_SEED_A; OUTLEN = BYTES_SEED_A;

  a_jagged_p = KECCAK_A_JAGGED;
  state = __keccak_init_avx2();
  s_state =  __init_s_state_avx2();

  // absorb final block
  for k = 0 to INLEN >> 3 {
    t = in.[u64 8 * k];
    l = a_jagged_p[k];
    l = #protect(l, ms);
    s_state[(int)l] = t;
  }
  l = a_jagged_p[INLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = INLEN - INLEN % 8 to INLEN {
    c = in[k];
    s_state[u8 (int)l] = c;
    l += 1;
  }

  s_state[u8 (int) l] = 0x1f;

  // i = (rate - 1) >> 3;
  i = (SHAKE256_RATE - 1) >> 3;
  l = a_jagged_p[(int) i];
  l = #protect(l, ms);
  l <<= 3;
  // l += ((rate - 1) & 0x7)
  l += (SHAKE256_RATE - 1) & 0x7;

  s_state[u8 (int) l] ^= 0x80;

  t = s_state[0];
  s_state[1] = t;
  s_state[2] = t;
  s_state[3] = t;

  for k = 0 to 7
  { state[k] ^= s_state[u256 k]; }

  // squeeze final block
  state, ms = __keccakf1600_avx2(state, ms);

  for k = 0 to 7
  { s_state[u256 k] = state[k]; }

  for k = 0 to OUTLEN >> 3 {
    l = a_jagged_p[k];
    l = #protect(l, ms);
    t = s_state[(int) l];
    out.[u64 8 * k] = t;
  }
  l = a_jagged_p[OUTLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = OUTLEN - OUTLEN % 8 to OUTLEN {
    c = s_state[u8 (int) l];
    out.[u8 k] = c;
    l += 1;
  }

  return out, ms;
}

#[returnaddress="stack"]
fn __shake256_r(reg ptr u8[4 * NNBAR] out, reg const ptr u8[1 + BYTES_SEED_SE] in, reg u64 ms) -> stack u8[4 * NNBAR], #msf reg u64
{
  stack u64[28] s_state;
  reg ptr u64[25] a_jagged_p;
  reg u256[7] state;
  reg u64 t l;
  reg u8 c;
  inline int INLEN OUTLEN OUTRND k;
  inline bool b;
  reg u64 i j8;

  INLEN = 1 + BYTES_SEED_SE;
  OUTLEN = 4 * NNBAR;
  OUTRND = OUTLEN / SHAKE256_RATE;

  a_jagged_p = KECCAK_A_JAGGED;
  state = __keccak_init_avx2();
  s_state =  __init_s_state_avx2();

  // absorb final block
  for k = 0 to INLEN >> 3 {
    t = in.[u64 8 * k];
    l = a_jagged_p[k];
    l = #protect(l, ms);
    s_state[(int)l] = t;
  }
  l = a_jagged_p[INLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = INLEN - INLEN % 8 to INLEN {
    c = in[k];
    s_state[u8 (int)l] = c;
    l += 1;
  }

  s_state[u8 (int) l] = 0x1f;

  // i = (rate - 1) >> 3;
  i = (SHAKE256_RATE - 1) >> 3;
  l = a_jagged_p[(int) i];
  l = #protect(l, ms);
  l <<= 3;
  // l += ((rate - 1) & 0x7)
  l += (SHAKE256_RATE - 1) & 0x7;

  s_state[u8 (int) l] ^= 0x80;

  t = s_state[0];
  s_state[1] = t;
  s_state[2] = t;
  s_state[3] = t;

  for k = 0 to 7
  { state[k] ^= s_state[u256 k]; }

  // intermediate squeeze blocks
  i = 0; j8 = 0;
  while {
    b = i < OUTRND;
  } (b) {
    ms = #update_msf(b, ms);
    state, ms = __keccakf1600_avx2(state, ms);

    for k = 0 to 7
    { s_state[u256 k] = state[k]; }

    for k = 0 to SHAKE256_RATE >> 3 {
        l = a_jagged_p[k];
        l = #protect(l, ms);
        t = s_state[(int) l];
        out.[u64 (int) j8 + 8 * k] = t;
    }
    j8 += SHAKE256_RATE;

    i += 1;
  }
  ms = #update_msf(!b, ms);

  // squeeze final block
  state, ms = __keccakf1600_avx2(state, ms);

  for k = 0 to 7
  { s_state[u256 k] = state[k]; }

  for k = 0 to OUTLEN % SHAKE256_RATE >> 3 {
    l = a_jagged_p[k];
    l = #protect(l, ms);
    t = s_state[(int) l];
    out.[u64 OUTRND * SHAKE256_RATE + 8 * k] = t;
  }
  l = a_jagged_p[OUTLEN % SHAKE256_RATE >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = OUTLEN - OUTLEN % SHAKE256_RATE % 8 to OUTLEN {
    c = s_state[u8 (int) l];
    out.[u8 k] = c;
    l += 1;
  }

  return out, ms;
}

#[returnaddress="stack"]
fn __shake256_pkh(reg ptr u8[BYTES_SEC] out, reg const ptr u8[BYTES_PK] in, reg u64 ms) -> stack u8[BYTES_SEC], #msf reg u64
{
  stack u64[28] s_state;
  reg ptr u64[25] a_jagged_p;
  reg u256[7] state;
  reg u64 t l;
  reg u8 c;
  inline int INLEN OUTLEN INRND k;
  inline bool b;
  reg u64 i j8;

  INLEN = BYTES_PK; OUTLEN = BYTES_SEC;
  INRND = INLEN / SHAKE256_RATE;

  a_jagged_p = KECCAK_A_JAGGED;
  state = __keccak_init_avx2();
  s_state =  __init_s_state_avx2();

  // absorb intermediate blocks
  i = 0; j8 = 0;
  while {
    b = i < INRND;
  } (b) {
    ms = #update_msf(b, ms);

    for k = 0 to SHAKE256_RATE >> 3 { 
        t = in.[u64 (int) j8 + 8 * k];
        l = a_jagged_p[k];
        l = #protect(l, ms);
        s_state[(int) l] = t;
    }
    j8 += SHAKE256_RATE;

    t = s_state[0];
    s_state[1] = t;
    s_state[2] = t;
    s_state[3] = t;

    for k = 0 to 7
    { state[k] ^= s_state[u256 k]; }

    state, ms = __keccakf1600_avx2(state, ms);

    i += 1;
  }
  ms = #update_msf(!b, ms);

  // absorb final block
  s_state = __init_s_state_avx2();
  for k = 0 to (INLEN % SHAKE256_RATE) >> 3 {
    t = in.[u64 INRND * SHAKE256_RATE + 8 * k];
    l = a_jagged_p[k];
    l = #protect(l, ms);
    s_state[(int)l] = t;
  }
  l = a_jagged_p[(INLEN % SHAKE256_RATE) >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = 0 to (INLEN % SHAKE256_RATE) % 8 {
    c = in[INLEN - (INLEN % SHAKE256_RATE) % 8 + k];
    s_state[u8 (int)l + k] = c;
  }

  s_state[u8 (int) l + (INLEN % SHAKE256_RATE) % 8] = 0x1f;

  // i = (rate - 1) >> 3;
  i = (SHAKE256_RATE - 1) >> 3;
  l = a_jagged_p[(int) i];
  l = #protect(l, ms);
  l <<= 3;
  // l += ((rate - 1) & 0x7)
  l += (SHAKE256_RATE - 1) & 0x7;

  s_state[u8 (int) l] ^= 0x80;

  t = s_state[0];
  s_state[1] = t;
  s_state[2] = t;
  s_state[3] = t;

  for k = 0 to 7
  { state[k] ^= s_state[u256 k]; }

  // squeeze final block
  state, ms = __keccakf1600_avx2(state, ms);

  for k = 0 to 7
  { s_state[u256 k] = state[k]; }

  for k = 0 to OUTLEN >> 3 {
    l = a_jagged_p[k];
    l = #protect(l, ms);
    t = s_state[(int) l];
    out.[u64 k * 8] = t;
  }
  l = a_jagged_p[OUTLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = OUTLEN - OUTLEN % 8 to OUTLEN {
    c = s_state[u8 (int) l];
    out.[u8 k] = c;
    l += 1;
  }

  return out, ms;
}

#[returnaddress="stack"]
fn __shake256_SE_k(reg ptr u8[BYTES_SEED_SE + BYTES_SEC] out, reg const ptr u8[2 * BYTES_SEC + BYTES_SALT] in, reg u64 ms) -> stack u8[BYTES_SEED_SE + BYTES_SEC], #msf reg u64 {
  stack u64[28] s_state;
  reg ptr u64[25] a_jagged_p;
  reg u256[7] state;
  reg u64 t l;
  reg u8 c;
  inline int INLEN OUTLEN k;
  inline bool b;
  reg u64 i j j8;

  INLEN = 2 * BYTES_SEC + BYTES_SALT;
  OUTLEN = BYTES_SEED_SE + BYTES_SEC;

  a_jagged_p = KECCAK_A_JAGGED;
  state = __keccak_init_avx2();
  s_state =  __init_s_state_avx2();

  // absorb final block
  for k = 0 to INLEN >> 3 {
    t = in.[u64 8 * k];
    l = a_jagged_p[k];
    l = #protect(l, ms);
    s_state[(int)l] = t;
  }
  l = a_jagged_p[INLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = INLEN - INLEN % 8 to INLEN {
    c = in[k];
    s_state[u8 (int)l] = c;
    l += 1;
  }

  s_state[u8 (int) l] = 0x1f;

  // i = (rate - 1) >> 3;
  i = (SHAKE256_RATE - 1) >> 3;
  l = a_jagged_p[(int) i];
  l = #protect(l, ms);
  l <<= 3;
  // l += ((rate - 1) & 0x7)
  l += (SHAKE256_RATE - 1) & 0x7;

  s_state[u8 (int) l] ^= 0x80;

  t = s_state[0];
  s_state[1] = t;
  s_state[2] = t;
  s_state[3] = t;

  for k = 0 to 7
  { state[k] ^= s_state[u256 k]; }

  // squeeze final block
  state, ms = __keccakf1600_avx2(state, ms);

  for k = 0 to 7
  { s_state[u256 k] = state[k]; }

  j = 0; j8 = 0;
  for k = 0 to OUTLEN >> 3 {
    l = a_jagged_p[k];
    l = #protect(l, ms);
    t = s_state[(int) l];
    out.[u64 8 * k] = t;
  }
  l = a_jagged_p[OUTLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = OUTLEN - OUTLEN % 8 to OUTLEN {
    c = s_state[u8 (int) l];
    out.[u8 8 * k] = c;
    l += 1;
  }

  return out, ms;
}


#[returnaddress="stack"]
fn __shake256_encap_r(reg ptr u8[2 * (2 * NNBAR + NBAR * NBAR)] out, reg const ptr u8[1 + BYTES_SEED_SE] in, reg u64 ms) -> stack u8[2 * (2 * NNBAR + NBAR * NBAR)], #msf reg u64 {
  stack u64[28] s_state;
  reg ptr u64[25] a_jagged_p;
  reg u256[7] state;
  reg u64 t l;
  reg u8 c;
  inline int INLEN OUTLEN OUTRND k;
  inline bool b bb;
  reg u64 i j j8;

  INLEN = 1 + BYTES_SEED_SE;
  OUTLEN = 2 * (2 * NNBAR + NBAR * NBAR);
  OUTRND = OUTLEN / SHAKE256_RATE;

  a_jagged_p = KECCAK_A_JAGGED;
  state = __keccak_init_avx2();
  s_state =  __init_s_state_avx2();

  // absorb final block
  for k = 0 to INLEN >> 3 {
    t = in.[u64 8 * k];
    l = a_jagged_p[k];
    l = #protect(l, ms);
    s_state[(int)l] = t;
  }
  l = a_jagged_p[INLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = INLEN - INLEN % 8 to INLEN {
    c = in[k];
    s_state[u8 (int)l] = c;
    l += 1;
  }

  s_state[u8 (int) l] = 0x1f;

  // i = (rate - 1) >> 3;
  i = (SHAKE256_RATE - 1) >> 3;
  l = a_jagged_p[(int) i];
  l = #protect(l, ms);
  l <<= 3;
  // l += ((rate - 1) & 0x7)
  l += (SHAKE256_RATE - 1) & 0x7;

  s_state[u8 (int) l] ^= 0x80;

  t = s_state[0];
  s_state[1] = t;
  s_state[2] = t;
  s_state[3] = t;

  for k = 0 to 7
  { state[k] ^= s_state[u256 k]; }

  // intermediate squeeze blocks
  i = 0; j8 = 0;
  while {
    b = i < OUTRND;
  } (b) {
    ms = #update_msf(b, ms);
    state, ms = __keccakf1600_avx2(state, ms);

    for k = 0 to 7
    { s_state[u256 k] = state[k]; }

    for k = 0 to SHAKE256_RATE >> 3 {
        l = a_jagged_p[k];
        l = #protect(l, ms);
        t = s_state[(int) l];
        out.[u64 (int) j8 + 8 * k] = t;
    }
    j8 += SHAKE256_RATE;

    i += 1;
  }
  ms = #update_msf(!b, ms);

  // squeeze final block
  state, ms = __keccakf1600_avx2(state, ms);

  for k = 0 to 7
  { s_state[u256 k] = state[k]; }

  j = 0;
  for k = 0 to OUTLEN % SHAKE256_RATE >> 3 {
    l = a_jagged_p[k];
    l = #protect(l, ms);
    t = s_state[(int) l];
    out.[u64 OUTRND * SHAKE256_RATE + 8 * k] = t;
  }
  l = a_jagged_p[OUTLEN % SHAKE256_RATE >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = OUTLEN - OUTLEN % SHAKE256_RATE % 8 to OUTLEN {
    c = s_state[u8 (int) l];
    out.[u8 k] = c;
    l += 1;
  }

  return out, ms;
}

#[returnaddress="stack"]
fn __shake256_ss(reg ptr u8[BYTES_SEC] out, reg const ptr u8[BYTES_CT + BYTES_SEC] in, reg u64 ms) -> stack u8[BYTES_SEC], #msf reg u64
{
  stack u64[28] s_state;
  reg ptr u64[25] a_jagged_p;
  reg u256[7] state;
  reg u64 t l;
  reg u8 c;
  inline int INLEN OUTLEN INRND k;
  inline bool b bb;
  reg u64 i j8;

  INLEN = BYTES_CT + BYTES_SEC;
  OUTLEN = BYTES_SEC;
  INRND = INLEN / SHAKE256_RATE;

  a_jagged_p = KECCAK_A_JAGGED;
  state = __keccak_init_avx2();
  s_state =  __init_s_state_avx2();

  // absorb intermediate blocks
  i = 0; j8 = 0;
  while {
    b = i < INRND;
  } (b) {
    ms = #update_msf(b, ms);

    for k = 0 to SHAKE256_RATE >> 3 {
        t = in.[u64 (int) j8 + 8 * k];
        l = a_jagged_p[k];
        l = #protect(l, ms);
        s_state[(int) l] = t;
    }
    j8 += SHAKE256_RATE;

    t = s_state[0];
    s_state[1] = t;
    s_state[2] = t;
    s_state[3] = t;

    for k = 0 to 7
    { state[k] ^= s_state[u256 k]; }

    state, ms = __keccakf1600_avx2(state, ms);

    i += 1;
  }
  ms = #update_msf(!b, ms);

  // absorb final block
  s_state = __init_s_state_avx2();
  for k = 0 to INLEN % SHAKE256_RATE >> 3 {
    t = in.[u64 INRND * SHAKE256_RATE + 8 * k];
    l = a_jagged_p[k];
    l = #protect(l, ms);
    s_state[(int)l] = t;
  }
  l = a_jagged_p[INLEN % SHAKE256_RATE >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = INLEN - INLEN % SHAKE256_RATE % 8 to INLEN {
    c = in[k];
    s_state[u8 (int)l] = c;
    l += 1;
  }

  s_state[u8 (int) l] = 0x1f;

  // i = (rate - 1) >> 3;
  i = (SHAKE256_RATE - 1) >> 3;
  l = a_jagged_p[(int) i];
  l = #protect(l, ms);
  l <<= 3;
  // l += ((rate - 1) & 0x7)
  l += (SHAKE256_RATE - 1) & 0x7;

  s_state[u8 (int) l] ^= 0x80;

  t = s_state[0];
  s_state[1] = t;
  s_state[2] = t;
  s_state[3] = t;

  for k = 0 to 7
  { state[k] ^= s_state[u256 k]; }

  // squeeze final block
  state, ms = __keccakf1600_avx2(state, ms);

  for k = 0 to 7
  { s_state[u256 k] = state[k]; }

  for k = 0 to OUTLEN >> 3 {
    l = a_jagged_p[k];
    l = #protect(l, ms);
    t = s_state[(int) l];
    out.[u64 8 * k] = t;
  }
  l = a_jagged_p[OUTLEN >> 3];
  l = #protect(l, ms);
  l <<= 3;

  for k = OUTLEN - OUTLEN % 8 to OUTLEN {
    c = s_state[u8 (int) l];
    out.[u8 k] = c;
    l += 1;
  }

  return out, ms;
}
